<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>node</title>
    <link href="/2021/02/24/nodejs/"/>
    <url>/2021/02/24/nodejs/</url>
    
    <content type="html"><![CDATA[<h3 id="node"><a href="#node" class="headerlink" title="node"></a>node</h3><h5 id="fs文件系统模块"><a href="#fs文件系统模块" class="headerlink" title="fs文件系统模块"></a>fs文件系统模块</h5><p>  1.读文件： fs.readFile()</p><p>  2.写文件： fs.writeFile()</p><h5 id="path路径模块"><a href="#path路径模块" class="headerlink" title="path路径模块"></a>path路径模块</h5><ol><li>多个路径片段进行组合： path.join()</li><li>获取路径中的文件名称： path.basename()</li><li>获取文件拓展名：path.extname()</li></ol><h5 id="http模块"><a href="#http模块" class="headerlink" title="http模块"></a>http模块</h5><ul><li><p>创建服务器</p><ol><li><p>引入 http 模块 </p></li><li><p>创建服务实例</p></li><li><p>绑定事件, 监听请求</p></li></ol></li></ul><ol start="4"><li>监听端口, 启动服务</li></ol><ul><li><p>请求对象</p><p>一、requset 请求对象</p><p> 提供了获取客户端相关的请求属性, 比如: </p><p> - req.url 请求的路径</p><p> - req.method 请求的方式</p><p>二、response 响应对象</p><p> 提供了服务器响应数据相关的方法, 比如：</p><p> - res.setHeader() 设置响应头</p><p> - res.end() 响应数据内容</p></li></ul><h3 id="终端快捷键"><a href="#终端快捷键" class="headerlink" title="终端快捷键"></a>终端快捷键</h3><p>1.↑切换到上一行</p><p>2.tab快速补全</p><p>3.ctrl+u快速清空内容</p><p>4.clear清屏</p><h3 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h3><h5 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h5><p>​    把一个大的功能事物拆分成若干个小的模块，再通过不同模块之间的组合，分解和转化来完成功能</p><h5 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h5><p>​    1. 内置模块 （由 Node.js 官方提供的, 例如 fs, path, http 等）</p><p>​    2. 自定义模块 （自己创建的 js 文件）</p><p>​    3. 第三方模块 （由第三方开发的模块, 使用前需要先下载）</p><h5 id="模块作用域"><a href="#模块作用域" class="headerlink" title="模块作用域"></a>模块作用域</h5><p>​    不同模块中定义的方法和变量，只能在当前模块内访问，这种模块级别的限制叫做模块作用域</p><h5 id="module对象"><a href="#module对象" class="headerlink" title="module对象"></a>module对象</h5><p>​    1.尽量避免为exports对象重新赋值</p><p>​    2.重新赋值一个对象用module.exports</p><h3 id="包"><a href="#包" class="headerlink" title="包"></a>包</h3><h5 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h5><p>​    带有一个 package.json 文件的目录称为包, 用来描述多个模块之间互相依赖的关系, 通常第三方模块都是以一个包的形式存在, 又称为 “第三方包” </p><h5 id="包的管理命令"><a href="#包的管理命令" class="headerlink" title="包的管理命令"></a>包的管理命令</h5><p>  一、下载一个指定的包 </p><p>   <code>npm i 包的具体名称</code> </p><p>  二、查看一个指定包</p><p>   <code>npm view 包的具体名称</code></p><p>  三、下载指定版本的包</p><p>   <code>npm i 包的具体名称@版本号</code></p><p>   四、快速创建包管理配置文件 </p><p>   在项目的根目录下执行 <code>npm init -y</code> 命令</p><p>   五、一次性安装所有包的命令</p><p>   npm i</p><p>   六、卸载指定的包 </p><p>   执行 <code>npm uninstall 包名称</code></p><p>  七、安装开发测试阶段用到的包</p><p>   npm i -D 包名称@版本号</p><p>  八、打开npmrc文件</p><p>  code ~/.npmrc</p><p>  九、使用nrm切换源</p><p>  npm i -g nrm<code>==&gt;</code>nrm ls<code> ==&gt;</code>nrm use taobao</p><p>  十、在包的发布目录下面执行命令</p><p>   npm publish</p><p>  十一、删除已经发布的包</p><p>  npm unpublish 包名称 –force</p><h3 id="模块加载机制"><a href="#模块加载机制" class="headerlink" title="模块加载机制"></a>模块加载机制</h3><h5 id="模块优先从缓存中进行加载"><a href="#模块优先从缓存中进行加载" class="headerlink" title="模块优先从缓存中进行加载"></a>模块优先从缓存中进行加载</h5><p>​    模块在第一次被加载后会被缓存，不论是内置核心模块、用户自定义模块还是第三方模块，都有对应的缓存策略以提高加载效率</p><h5 id="1-内置模块的加载机制"><a href="#1-内置模块的加载机制" class="headerlink" title="1.内置模块的加载机制"></a>1.内置模块的加载机制</h5><p>​    require()总是会优先加载核心模块，即使有同名文件</p><h5 id="2-自定义模块加载机制"><a href="#2-自定义模块加载机制" class="headerlink" title="2.自定义模块加载机制"></a>2.自定义模块加载机制</h5><ul><li>必须以’/‘，’./‘或’../‘开头，否则会被默认为是核心模块</li><li>如果按确切的文件名没有找到，则Node.js会尝试带上.js、.json或.node拓展名再加载</li><li>目录加载顺序为：先寻找package.json文件，并寻找main属性作为require的入口；若上述找不到，Node.js会试图加载目录下index.js或index.node文件</li></ul><h5 id="3-第三方模块加载机制"><a href="#3-第三方模块加载机制" class="headerlink" title="3.第三方模块加载机制"></a>3.第三方模块加载机制</h5><p>   如果传递给 require() 的模块标识符不是一个核心模块，也没有以 ‘/‘ 、 ‘../‘ 或 ‘./‘ 开头， 那么 Node.js 会从当前模块的父目录开始，尝试从它的 /node_modules 目录里加载模块。如果还是没有找到， 则移动到再上一层父目录，直到文件系统的根目录</p><h3 id="express"><a href="#express" class="headerlink" title="express"></a>express</h3><h5 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h5><p>express本质是一个npm的第三方包</p><h5 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h5><ul><li>npm i <a href="mailto:&#101;&#120;&#112;&#114;&#x65;&#115;&#115;&#64;&#52;&#46;&#49;&#x37;&#x2e;&#49;">&#101;&#120;&#112;&#114;&#x65;&#115;&#115;&#64;&#52;&#46;&#49;&#x37;&#x2e;&#49;</a></li><li>全局动态监测文件变化的插件nodemon:npm i -g nodemon</li></ul><h5 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h5><ul><li><p>引入包</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-variable">const</span> <span class="hljs-variable">express</span> = <span class="hljs-function"><span class="hljs-title">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>)</span><br></code></pre></td></tr></table></figure></li><li><p>创建web服务器实例</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-variable">const</span> <span class="hljs-variable">app</span> = <span class="hljs-function"><span class="hljs-title">express</span>()</span><br></code></pre></td></tr></table></figure></li><li><p>启动服务，监听窗口</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">app.listen(<span class="hljs-number">3006</span>, <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;express running at http://localhost:3006&#x27;</span>);<br>&#125;)<br></code></pre></td></tr></table></figure></li><li><p>监听get请求</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">app</span><span class="hljs-selector-class">.get</span>(<span class="hljs-string">&#x27;/userinfo&#x27;</span>, (req, res) =&gt; &#123;<br>    <span class="hljs-selector-tag">res</span><span class="hljs-selector-class">.send</span>(&#123; <span class="hljs-attribute">name</span>: <span class="hljs-string">&#x27;xm&#x27;</span>, <span class="hljs-attribute">age</span>: <span class="hljs-number">20</span>, <span class="hljs-attribute">user_pic</span>: <span class="hljs-string">&#x27;xxx.jpg&#x27;</span> &#125;)<br>&#125;)<br></code></pre></td></tr></table></figure></li><li><p>监听post请求</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">app.post(<span class="hljs-string">&#x27;/login&#x27;</span>, <span class="hljs-function"><span class="hljs-params">(req, res)</span> =&gt;</span> &#123;<br>    res.send(<span class="hljs-string">&#x27;登录成功了&#x27;</span>)<br>&#125;)<br></code></pre></td></tr></table></figure></li><li><p>获取查询参数</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">app.post(<span class="hljs-string">&#x27;/getbooks&#x27;</span>, <span class="hljs-function"><span class="hljs-params">(req, res)</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(req.query);<br><br>    res.send(req.query)<br>&#125;)<br></code></pre></td></tr></table></figure></li><li><p>获取动态参数</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">app.get(<span class="hljs-string">&#x27;/del/:id/:name&#x27;</span>, <span class="hljs-function"><span class="hljs-params">(req, res)</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(req.params);<br><br>    res.send(req.params)<br>&#125;)<br></code></pre></td></tr></table></figure></li><li><p>托管静态资源</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs axapta">app.use(express.<span class="hljs-keyword">static</span>(path.<span class="hljs-keyword">join</span>(__dirname, <span class="hljs-string">&#x27;./assets&#x27;</span>)))<br></code></pre></td></tr></table></figure><h3 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h3></li></ul><h5 id="概念-3"><a href="#概念-3" class="headerlink" title="概念"></a>概念</h5><p>路由在广义上是指一种映射关系，在node.js中指的是客户端请求和服务端处理函数的映射关系</p><h5 id="路由模块的创建"><a href="#路由模块的创建" class="headerlink" title="路由模块的创建"></a>路由模块的创建</h5><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">const express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>)<br><br><span class="hljs-regexp">//</span>导入路由模块<br>const router = express.Router()<br><br>router.get(<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-function"><span class="hljs-params">(req, res)</span> =&gt;</span> &#123;<br>    res.send(<span class="hljs-string">&#x27;ok&#x27;</span>)<br>&#125;)<br><br>router.get(<span class="hljs-string">&#x27;/api&#x27;</span>, <span class="hljs-function"><span class="hljs-params">(req, res)</span> =&gt;</span> &#123;<br>    res.send(<span class="hljs-string">&#x27;get&#x27;</span>)<br>&#125;)<br><br>router.post(<span class="hljs-string">&#x27;/api&#x27;</span>, <span class="hljs-function"><span class="hljs-params">(req, res)</span> =&gt;</span> &#123;<br>    res.send(<span class="hljs-string">&#x27;post&#x27;</span>)<br>&#125;)<br><br><span class="hljs-built_in">module</span>.<span class="hljs-built_in">exports</span> = router<br></code></pre></td></tr></table></figure><h3 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h3><h5 id="概念-4"><a href="#概念-4" class="headerlink" title="概念"></a>概念</h5><ul><li>中间件泛指业务流程的中间处理环节，本质上是一个处理函数</li><li>参数列表是req请求对象，res响应对象和next回调函数</li><li>中间件函数内部必须调用next()将控制权传给下一个中间件，否则请求将被挂起</li></ul><h5 id="中间件的范围"><a href="#中间件的范围" class="headerlink" title="中间件的范围"></a>中间件的范围</h5><ul><li>全局中间件</li><li>局部中间件</li></ul><h5 id="中间件使用的注意事项"><a href="#中间件使用的注意事项" class="headerlink" title="中间件使用的注意事项"></a>中间件使用的注意事项</h5><ul><li>全局中间件的注册放在路由定义之前</li><li>一个客户端发送的请求可以调用多个中间件进行处理</li><li>中间件的处理函数一定要有next()调用</li><li>next函数之后不用写和业务无关的代码</li><li>多个中间件之间共享req和res</li></ul><h5 id="express内置中间件"><a href="#express内置中间件" class="headerlink" title="express内置中间件"></a>express内置中间件</h5><ul><li>express.static() 快速托管静态资源中间件</li><li>express.json() 解析客户端传递的json格式请求头数据</li><li>express.urlencoded() 客户端传递的urlcoded编码形式的请求体数据</li></ul><h3 id="cors"><a href="#cors" class="headerlink" title="cors"></a>cors</h3><h5 id="概念-5"><a href="#概念-5" class="headerlink" title="概念"></a>概念</h5><p>   (Cross-Origin Resource Sharing) 跨域资源共享, 由一系列的 HTTP 响应头组成, 这些响应头决定了浏览器是否阻止前端 js 代码发出跨域请求</p><h5 id="cors的响应头部"><a href="#cors的响应头部" class="headerlink" title="cors的响应头部"></a>cors的响应头部</h5><ul><li>Access-Control-Allow-Origin:url/* 指定允许访问该资源的url</li><li>Access-Control-Allow-Headers:a,b,c 指定了允许发送那些请求头</li><li>Access-Control-Allow-Methods:get,post 制定了允许发送何种请求类型</li></ul><h5 id="cors请求的分类"><a href="#cors请求的分类" class="headerlink" title="cors请求的分类"></a>cors请求的分类</h5><ul><li>简单请求：请求方式为get/post/head之一，无自定义请求头字段</li><li>预检请求：请求方式无get/post/head之一，存在自定义请求头字段，发送了application/json 格式数据</li></ul><p>​    浏览器会先发送一个options请求进行预检，以确认服务器是否允许该实际请求，完成后再发送真正的请求</p><h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><h5 id="概念-6"><a href="#概念-6" class="headerlink" title="概念"></a>概念</h5><p>数据库是专门用来组织，存储和管理数据的仓库</p><h5 id="组织解构"><a href="#组织解构" class="headerlink" title="组织解构"></a>组织解构</h5><p>数据库、数据表、数据行、字段</p><h5 id="sql语句"><a href="#sql语句" class="headerlink" title="sql语句"></a>sql语句</h5><h6 id="增"><a href="#增" class="headerlink" title="增"></a>增</h6><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> users(username, <span class="hljs-keyword">password</span>) <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;cc&#x27;</span>,<span class="hljs-string">&#x27;5647&#x27;</span>);<br></code></pre></td></tr></table></figure><h6 id="删"><a href="#删" class="headerlink" title="删"></a>删</h6><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">delete</span> <span class="hljs-keyword">from</span> users <span class="hljs-keyword">where</span> id=<span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><h6 id="改"><a href="#改" class="headerlink" title="改"></a>改</h6><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">update<span class="hljs-built_in"> users </span><span class="hljs-builtin-name">set</span> <span class="hljs-attribute">password</span>=<span class="hljs-string">&#x27;88888&#x27;</span> where <span class="hljs-attribute">id</span>=9;<br></code></pre></td></tr></table></figure><h6 id="查"><a href="#查" class="headerlink" title="查"></a>查</h6><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">select</span> username,status <span class="hljs-keyword">from</span> users<br></code></pre></td></tr></table></figure><h6 id="where子句"><a href="#where子句" class="headerlink" title="where子句"></a>where子句</h6><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> users <span class="hljs-keyword">where</span> status=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> users <span class="hljs-keyword">where</span> id&gt;=<span class="hljs-number">3</span>;<br><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> users <span class="hljs-keyword">where</span> id!=<span class="hljs-number">3</span>;<br><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> users <span class="hljs-keyword">where</span> id <span class="hljs-keyword">between</span> <span class="hljs-number">2</span> <span class="hljs-keyword">and</span> <span class="hljs-number">9</span>;<br><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> users <span class="hljs-keyword">where</span> username <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;%c%&#x27;</span>;<br></code></pre></td></tr></table></figure><h6 id="and和or运算符"><a href="#and和or运算符" class="headerlink" title="and和or运算符"></a>and和or运算符</h6><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">select * <span class="hljs-keyword">from</span><span class="hljs-built_in"> users </span>where id&lt;6 <span class="hljs-keyword">and</span> <span class="hljs-attribute">status</span>=1 <br>select * <span class="hljs-keyword">from</span><span class="hljs-built_in"> users </span>where id&lt;6 <span class="hljs-keyword">or</span> <span class="hljs-attribute">status</span>=1<br></code></pre></td></tr></table></figure><p>order by语句排序</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> users <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> status<br><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> users <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> id <span class="hljs-keyword">desc</span> <br><br>查询表中id大于<span class="hljs-number">3</span>的用户并根据id降序排列<br><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> users <span class="hljs-keyword">where</span> id&gt;<span class="hljs-number">2</span> <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> id <span class="hljs-keyword">desc</span> <br><br>先根据status值进行降序排列，在根据<span class="hljs-keyword">password</span>进行升序排列<br><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> users <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> status <span class="hljs-keyword">desc</span>,<span class="hljs-keyword">password</span> <span class="hljs-keyword">asc</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>webAPIs</title>
    <link href="/2021/02/09/webAPIs/"/>
    <url>/2021/02/09/webAPIs/</url>
    
    <content type="html"><![CDATA[<h3 id="webAPIs"><a href="#webAPIs" class="headerlink" title="webAPIs"></a>webAPIs</h3><ul><li><p>DOM</p><p>Doument Object Model</p><p>文档对象模型，是w3c推荐的处理可拓展标记语言的标准编程接口</p><p><img src="file:///D:/%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0/%E8%B5%84%E6%96%99/Web%20APIs-day01/4-%E7%AC%94%E8%AE%B0/images/1550731974575.png?lastModify=1608197349?lastModify=1608197352" alt="img"></p></li><li><p>文档：一个页面就是一个文档，DOM中使用document表示</p></li><li><p>节点：网页中的所有内容，在文档树中都是节点（标签、属性、文本、注释等），使用node表示</p></li><li><p>标签节点：网页中的所有标签，通常称为元素节点，又简称为“元素”，使用element表示</p></li></ul><h3 id="dom"><a href="#dom" class="headerlink" title="dom"></a>dom</h3><ul><li><p>获取页面元素</p><ul><li><p>根据id获取</p><p>document.getElementById(‘time’)</p><p>*返回的是一个元素对象</p></li><li><p>根据标签名获取元素</p><p>document.getElementsByTagName(‘li’)</p><p>*得到的结果是一个伪数组</p><p>API中名称带有elements、children、all返回的都是伪数组</p><p>伪数组：具有length属性，支持索引访问和for循环遍历，不支持原生数组方法</p></li></ul></li><li><p>H5新增方法</p><ul><li><p>通过类名获取</p><p>document.getElementsByClassName(‘.box’)</p></li><li><p>通过css选择器中id为nav额div元素</p><p>document.querySelector(‘#nav’) </p></li><li><p>获取mune下所有li标签</p><p>document.querySelectorAll(‘.menu li’)</p></li></ul></li><li><p>事件</p><ul><li>事件源(不能是伪数组，必须是单个元素对象)  获取对象 document.querySelector</li><li>事件类型  用何种触发onclick</li><li>事件处理程序  通过函数赋值完成</li></ul></li><li><p>获取、修改元素属性方法  element.属性名</p></li><li><p>表单元素</p><ul><li>value表单值</li><li>type表单类型</li><li>checked 是否选中</li><li>disabled 是否禁用</li><li>selected是否选中</li></ul></li><li><p>样式属性修改</p><p>this.style.width</p><p>所有css属性带有-的都要遵循驼峰命名法</p></li><li><p>排他思想：先清空所有，在设置自己</p></li><li><p>自定义属性的操作</p><p>element.getAttribute() 获取自定义属性</p><p>element.setAttribute()  修改自定义属性</p><p>element.removeAttribute()  移除自定义属性</p></li><li><p>节点操作</p><p>利用父子兄节点关系获取元素</p><p>nodeType  节点类型</p><p>nodeName  节点名称</p><p>nodeValue  节点值</p><ul><li><p>获取父节点</p><p>li.parentNode</p></li><li><p>获取子节点</p><p>li.childrenNote</p></li><li><p>获取兄弟节点</p><p>li.previousElementSibling获取上一兄弟节点</p><p>li.nextElementSibling</p><p>获取下一兄弟节点</p></li><li><p>创建添加元素方法</p><p> var span = document.createElement(‘span’)</p><p>span.innerHTML = ‘hello’</p><p>ul.appendChild(span)    把span添加到最后面</p><p>ul.insertBefore(span, ul.children[1])    把span添加到盒子2前面</p></li><li><p>移除子节点</p><p>父元素.removeChild()</p></li><li><p>复制元素</p><p>元素.cloneNode(true)</p></li></ul></li><li><p>页面元素的添加</p><p>1.box.innerHTML = ‘<span>hello</span>‘</p><p>2.语义化声明</p><p>3.document.write()会导致·页面重绘</p><ul><li><p>统计元素执行效率</p><p>console.time();</p><p>console.timeEnd();</p></li><li><p>事件高级</p></li><li><p>注册事件</p><p>1.传统方式</p><p>2.事件监听注册事件（可为同一元素添加不同的监听器）</p><p>btn2.addEventListener(‘click’, function () {</p><p>​      console.log(‘hi’);</p><p>​    })</p></li><li><p>删除事件</p><p>box.removeEventListener(‘click’, fn)</p></li><li><p>dom事件流</p><p>事件的传播顺序</p><p>1.捕获阶段（从上到下）</p><p>2.目标阶段</p><p>3.冒泡阶段（从下到上）</p></li><li><p>事件对象</p><p>btn.addEventListener(‘click’, function (e) {</p><p>​      console.log(e);</p><p>​    })</p><p>*e.target与this的区别  e.target不一定是事件的绑定元素（遵循冒泡阶段），this始终指向事件的绑定者</p></li><li><p>阻止事件默认行为</p><p>a.addEventListener(‘click’, function (e) {</p><p>​      e.preventDefault()</p><p>​    })</p><p>return false也可以阻止默认行为</p></li><li><p>阻止事件冒泡</p><p>box3.addEventListener(‘click’, function (e) {</p><p>​      e.stopPropagation()  //阻止事件冒泡</p><p>​    })</p></li><li><p>事件委托</p><p>*不给每个子节点单独设置事件监听器，而是事件监听器设置在其父节点上，然后利用冒泡原理影响每一个子节点。不用操作每个子元素，只进行一次dom操作，极大提高了性能，可以给动态创建的元素添加事件。</p><p>var ul = document.querySelector(‘ul’)</p><p>ul.addEventListener(‘click’, function (e) { e.target.style.backgroundColor = ‘pink’</p><p>​    })</p></li><li><p>鼠标事件</p><ol><li>鼠标右键事件: contextmenu </li><li>鼠标选中事件：selectstart</li><li>鼠标双击事件：dblclick</li><li>鼠标按下事件：mousedown</li><li>鼠标松开事件：mouseup</li><li>鼠标滚轮事件：wheel</li><li>鼠标移动事件：mousemove</li><li>鼠标经过件:mouseover</li><li>鼠标离开事件:mouseout</li></ol></li><li><p>获取鼠标位置</p><p>document.addEventListener(‘click’, function (e) {</p><p>​      console.log(e.pageX, e.pageY);</p><p>​    })</p></li><li><p>键盘事件</p><ol><li>按下任意按键事件：keydown</li><li>松开任意按键事件：keyup</li><li>除 Shift、Fn、CapsLock 外的任意键被按住：keypress</li></ol><ul><li>e.keyCode == 13 回车键</li></ul></li><li><p>元素自动获取事件</p><p>element.click()</p></li></ul></li></ul><h3 id="bom"><a href="#bom" class="headerlink" title="bom"></a>bom</h3><p>浏览器对象模型</p><ul><li><p>window对象</p><p>1.顶级全局对象，可直接调用</p><p>2.全局变量会自动倒挂到window对象下</p></li><li><p>window对象及onload事件</p></li><li><p>调整浏览器窗口大小</p><p>window.addEventListener(‘resize’, function () {</p><p>​      console.log(window.innerWidth);</p><p>​      for (i = 0; i &lt; lis.length; i++) {</p><p>​        lis[i].style.width = window.innerWidth &lt; 800 ? ‘50%’ : ‘25%’</p><p>​      }</p><p>​    })</p></li><li><p>定时器</p><p>setTimeout(函数名, 5000)</p></li><li><p>销毁定时器</p><p>clearTimeout(id1)</p></li><li><p>周期性定时器</p><p>setInterval(time(), 1000)</p></li><li><p>销毁周期定时器</p><p>clearInterval(id1)</p></li><li><p>this指向问题</p><p>1.构造函数中this指向构造函数创建的实例对象</p><p>2.非函数指向window</p><p>3.函数指向调用者</p></li><li><p>js中的同步和异步</p><p>异步任务指回调函数</p><p>同步主线程优先执行</p><p>*主线程执行栈执行完了同步任务后，会不断地检查任务队列中是否存在异步任务，如果存在就把异步任务添加到主线程栈执行，然后不断循环上述步骤</p></li></ul><h4 id="三大对象"><a href="#三大对象" class="headerlink" title="三大对象"></a>三大对象</h4><ul><li><p>location 对象上的常用属性</p><p>​      (1) href属性：获取当前 url 或 跳转到某个 url</p><p>​      (2) search属性： 获取 URL 中的查询参数 ?key=value</p><p>​      (3) hash属性： 获取 URL 中的锚点 #abc</p></li><li><p>navigator对象</p><p>UA=navigator.user.Agent</p></li><li><p>history</p><p>history.go(1)</p><p>history.go(-1)</p></li></ul><h4 id="位置信息"><a href="#位置信息" class="headerlink" title="位置信息"></a>位置信息</h4><ul><li><p>offset系列(获取元素位置)</p><p>offsetLeft  左偏移 </p><p>offsetTop  上偏移 </p><p>offsetWidth  宽度</p><p>offsetHeight  高度</p><p>tips：不会计算transform移动后距离</p></li><li><p>client</p><ol><li>clientWidth 返回元素的宽度（包括padding 不包括 border）</li><li>clientHeight 返回元素的高度（包括padding 不包括 border）</li><li>clientLeft 返回元素左边框的大小</li><li>clientTop 返回元素上边框的大小</li></ol></li><li><p>立即执行函数</p><p>1.(function(a,b){})(3,5)</p><p>2.(function(a,b){}(3,5))</p></li><li><p>scroll</p><p>​      1. scrollLeft 返回元素内容被卷去左边的距离</p><p>​      2. scrollTop 返回元素内容被卷去上边的距离</p><p>​      3. scrollWidth 返回元素只包括自身内容宽度（包括padding 不包括 border）</p><ol start="4"><li>scrollHeight 返回元素只包括自身内容高度（包括padding 不包括 border）</li></ol></li><li><p>mouseenter和mouseleave</p><p>mouseenter 鼠标经过事件 (不存在事件冒泡)</p><p>mouseleave 鼠标离开事件 (不存在事件冒泡)</p></li><li><p>移动端触摸</p><p>​    1. 移动端兼容性相对较好，H5、C3都可以放心使用，不用考虑 IE 浏览器兼容性</p><p>​    2. 移动端事件是通过手指触发的，触屏事件 touch</p><p>​    3. touch事件包含三类：</p><p>​        touchstart 手指触摸到元素时触发 （mousedown）</p><p>​        touchmove 手指在元素上移动时触发 (mousemove)</p><p>​        touchend 手指离开元素时触发 (mouseup)</p></li><li><p>操作元素类名的新方法， classList 属性  IE 11+ （建议移动端使用）</p><p>​      1. 获取所有类名 ele.classList</p><p>​      2. 添加类名 ele.classList.add(类名)</p><p>​      3. 删除类名 ele.classList.remove(类名) </p><ol start="4"><li>切换类名 ele.classList.toggle(类名) 让类名从无到有，从有到无</li></ol></li><li><p>vw 视口宽度</p></li><li><p>本地存储的两个对象</p><p>​    二、本地存储的两个对象（面试喜欢问这个）</p><p>​      sessionStorage(会话存储): 生命周期是关闭当前的标签页, 只能在当前域共享 (大小 5M)</p><p>​      localStorage(持久化存储): 生命周期永久有效，除非手动进行删除，所有页面共享 (大小 20M)</p></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>js基础</title>
    <link href="/2021/02/09/js%E5%9F%BA%E7%A1%80/"/>
    <url>/2021/02/09/js%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="js基础"><a href="#js基础" class="headerlink" title="js基础"></a>js基础</h1><p>js是运行在客户端的脚本语言</p><ul><li><p>js组成</p><p>1.ECMScript</p><p>2.DOM 页面文档对象</p><p>3.BOM  浏览器对象</p></li><li><p>引入方法</p><p>行内式、内嵌式、外部引入</p></li><li><p>js输入和输出语句</p><ul><li>prompt 输入框（返回字符串）</li></ul></li></ul><ul><li><p>alert 弹出警示框</p></li><li><p>console 控制台输出</p><p>console.log</p></li><li><p>变量</p><p>用于存放数据的容器，本质是在内存中申请一块空间用来存放数据       </p><ul><li>变量使用：</li></ul><p>1.声明，var age;</p><p>2.赋值，把值存入赋值中 age=10;</p><p>*变量的初始化：var age=18;</p><ul><li><p>更新变量</p></li><li><p>同时声明多个变量  </p></li><li><p>声明变量的特殊情况</p><p>1.只声明不赋值   undefined</p><p>2.不声明不赋值  报错</p><p>3.不声明直接赋值 变成全局变量</p></li><li><p>变量命名规范</p><p>1.区分大小写</p><p>2.不能以数字开头</p><p>3.不能是关键字和保留字</p><p>4.变量名语义化</p><p>5.驼峰命名法，首字母小写后面单词的首字母大写</p></li></ul></li><li><p>数据类型        </p><p>不同数据占用存储空间不同，为了充分利用存储空间，将数据分为不同数据类型</p><p>javaScript是一种弱语言或动态语言，变量的数据类型是由js引擎根据=右边的变量值的数据类型判断的，运行完后就可以确定数据类型   </p><ul><li><p>简单数字类型</p><p>1.Number 数字型（整数和小数） </p><p>前面加0表示八进制 </p><p>0x表示十六进制</p><p>Infinity 无穷大</p><p>-Infinity 无穷小</p><p>NaN 非数字                                                                               </p><p>*isNaN用来判断非数字</p><p>2.字符串</p><p>   \n  换行</p><p>   \    斜杠</p><p>   &#39;   单引号</p><p>   &quot;  双引号</p><p>   \t   缩进</p><p>   \b  空格</p><p>  *字符串长度 length</p><p>​    console.log(str.length)</p><p>  *字符串拼接  +</p><p>​    console.log（xx+xx）</p><p>  *变量和字符串相连 引引加加</p><p>3.布尔型</p><p>   var flag=true;</p><p>   布尔型和数字相加时，true和false当数字1和0</p><p>4.undefined</p><p>   undefined +1   NaN </p><p>5.null</p></li></ul></li><li><p>获取检测的数据类型</p><p>console.log(typeof num)</p></li><li><p>数据类型的转换</p><ul><li>转换为字符串型</li></ul><p>1.变量.toString()</p><p>2.toString 强制转换</p><p>3.*加号转换字符串</p><p>console.log(num+’ ‘)</p><ul><li>*转换为数字型</li></ul><p>1.console.log(parseInt(age))   整数</p><p>2.parseFloat  浮点数</p><p>3.console.log(Number(str))</p><p>4.console.log(‘12’-0)  * /也可以</p><ul><li><p>转换为布尔型</p><p>非0为真</p></li></ul><p>​</p><h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3></li><li><p>算数运算符</p><p>+、-、*、/、%</p><p>浮点数不参与运算</p></li><li><p>表达式和返回值</p><ul><li>有数字、运算符、变量组成的式子是表达式</li></ul></li><li><p>递增递减运算符</p><ul><li><p>前置递增运算符</p><p>++num 即 num=num+1 </p><p>先自加在返回值</p></li><li><p>后置递增运算符 </p><p>num++</p><p>先返回值在自加</p></li></ul></li><li><p>比较运算符</p><p>=赋值</p><p>==判等号（会转型）</p><p>===数值和数据类型</p></li><li><p>逻辑运算符</p><ul><li>布尔值</li></ul><p>​      1.逻辑与 &amp;&amp;  同真为真</p><p>​      2.逻辑或 || 同假为假</p><p>​      3.逻辑非 !</p><ul><li>逻辑中断：左边有结果就不再进行右边的运算</li><li>数字或表达式短路运算</li></ul><p>​       1.逻辑与  返回假</p><p>​       2.逻辑或  返回真</p><ul><li><p>赋值运算符</p><p>1.=直接赋值</p><p>2.+=、-= 加、减后赋值</p><p>3.*=、/=、%=</p></li><li><p>运算符优先级</p><p>() </p><p>++ 、– 、!</p><p>*、  \、%、+、-</p><p>、&gt;、&gt;=、&lt;、&lt;=</p><p>==  != === !==</p><p>=</p><p>,</p><p>逻辑与比逻辑或优先级高</p></li></ul><h3 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h3><ul><li><p>顺序结构-</p></li><li><p>分支结构</p><p>if语句</p><p>switch</p></li><li><p>循环结构</p><p>for循环</p><p>双重for循环</p><p>while</p><p>do..while 先执行一次循环体</p></li><li><p>三元表达式</p><p>表达式1?表达式2:表达式3</p><p>1为真返回2,1否则返回3</p></li><li><p>标识符命名规范</p><p>1.语义化啊</p><p>2.变量用名词</p><p>3.函数用动词</p></li><li><p>断点调试  在浏览器里面</p></li></ul><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>将一组数据存放在一个变量名下</p><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><ul><li><p>arguments  函数内置对象，存储实参</p><p>伪数组</p><p>1.具有数组length属性</p><p>2.按照索引方式存储</p><p>3.没有真正数组的一些方法</p></li></ul><h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><ul><li><p>全局作用域</p></li><li><p>局部作用域（一定有函数） </p><p>变量不声明直接赋值会变成全局变量；形参也是局部变量 </p></li><li><p>作用域链</p><p>内部函数访问外部函数的变量，采取链式查找的方式来决定取值，即就近原则-</p></li><li><p>预解析</p><p>js引擎会把js里面的变量（不提升赋值）和函数提升到当前作用域 的最前面，函数声明优先级高于变量不高于变量赋值</p><ul><li>函数表达式只存在变量提升，不存在函数提升</li></ul></li></ul><h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><ul><li><p>特指一个具体的事物，由属性和行为组成</p></li><li><p>构造函数和对象</p><ul><li>对象是一个具体事物</li><li>构造函数是某一大类</li></ul></li><li><p>！new关键字的执行过程</p><p>1.在内存中创建一个空对象</p><p>2.this指向创建的空对象</p><p>3.执行构造函数，给空对象添加属性方法</p><p>4.返回这个对象（所以不需要return）</p></li><li><p>遍历对象</p><p>for…in遍历方式</p><p>for(var key in obj){</p><p>}</p></li><li><p>内置对象</p><ul><li><p>数学对象</p><p>Math.PI 圆周率</p><p>Math.abs 绝对值</p><p>Math..max 最大值</p><p>Math.min 最小值</p><p>Math.ceil 向上取整</p><p>Math.floor 向下取整</p><p>Math.round  四舍五入</p><p>Math.ranDom 随机数</p></li><li><p>Date日期对象</p></li></ul></li><li><p>数组方法</p><p>1.push 追加元素到末尾</p><p>2.unshift 向开头添加元素</p><p>3.pop 从数组末尾删除一个元素，返回删除的数</p><p>4.shift 从数组开头删除一个元素，返回删除数组</p><p>5.sort() 数组排序</p><p>6.reverse() 数组翻转</p><p>7.indexOf() 查找元素在数组中第一次出现的索引（没有元素返回-1）</p><p>8.lastIndexOf()  最后一次出现的索引位置</p></li><li><p>数组及字符串</p><ul><li>数组</li></ul><p>1.join把数组元素连接成字符串</p><p>2.slice方法，获取指定位置元素</p><p>3.splice用来删除数组元素，删除后数组元素组成新数组</p><p>4.concat用来拼接多个数组</p><ul><li>字符串</li></ul><p>简单数据类型在使用对象属性时会被包装为复杂数据类型，并在执行完后销毁</p><p>字符串在内存中的固定值不变，只会新增内存空间存放数据在指向原来的变量</p><p>1.拼接字符串 + 号</p><p>2.截取一段字符串：slice(开始位置，结束位置)</p><p>3.截取一段字符串：substr(开始位置，截取位数)</p><p>4.replace()替换字符串：只能替换符合条件的第一个字符串</p><p>5.split()把字符串按照指定字符进行分割，并把分割后的部分转化为数组</p><p>6.字符串转大写字母 toUpperCase()</p><p>7.字符串转小写字母 toLowerCase()</p><p>​</p></li></ul><h3 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h3><ul><li><p>栈和堆</p><p>栈内存：大小固定，用来存放简单数据类型和所有变量名以及函数名</p><p>堆内存：大小不固定，用来储存复杂数据类型</p></li></ul></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>JQuery</title>
    <link href="/2021/02/09/JQuery/"/>
    <url>/2021/02/09/JQuery/</url>
    
    <content type="html"><![CDATA[<h1 id="JQuery"><a href="#JQuery" class="headerlink" title="JQuery"></a>JQuery</h1><h3 id="DOM对象和JQ对象"><a href="#DOM对象和JQ对象" class="headerlink" title="DOM对象和JQ对象"></a>DOM对象和JQ对象</h3><p>​    // 1. 使用原生 WebApi 方法获取的元素就是 原生DOM 对象</p><p>​    // 2. 使用 $(参数) 方法获取的就是 jquery 对象, 本质上是把原生对象做了一层包装，获得的所有jq对象都是伪数组</p><p>​    // 3. 只有 jquery 对象才能使用相关快捷地操作方法；原生 DOM 对象不可以</p><h3 id="DOM对象和JQ对象互换"><a href="#DOM对象和JQ对象互换" class="headerlink" title="DOM对象和JQ对象互换"></a>DOM对象和JQ对象互换</h3><p>// 1. 把单个  jq 对象转成原生的 DOM 对象: jq对象[0] 或 jq对象.get(0)</p><p>// 2. 把原生的 DOM 对象转成 jq 对象:  $(dom对象)</p><h3 id="jq选择器"><a href="#jq选择器" class="headerlink" title="jq选择器"></a>jq选择器</h3><p>  // 1. 根据类名来获取元素</p><p>​      console.log($(‘.box’));</p><p>​      // 2. 根据 id 来获取元素</p><p>​      console.log($(‘#foo’));</p><p>​      // 3. 根据标签名来获取元素</p><p>​      console.log($(‘input’));</p><p>​      // 4. 根据子代选择器获取元素</p><p>​      console.log($(‘ul&gt;li’));</p><p>​      // 5. 根据后代选择器获取元素</p><p>​      console.log($(‘ul .current’));</p><p>​      // 6. 属性选择器</p><p>​      console.log($(‘[name = password]’));</p><h4 id="筛选方法"><a href="#筛选方法" class="headerlink" title="筛选方法"></a>筛选方法</h4><p>​    // 1. 获取父元素</p><p>​    console.log($(‘ul’).parent());</p><p>​    // 2. 获取指定元素的祖先元素</p><p>​    console.log($(‘.bar’).parents());</p><p>​    // 3. 获取所有的子元素</p><p>​    console.log($(‘ul’).children());</p><p>​    // 4. 查找获取所有的后代元素（包括子孙元素）</p><p>​    console.log($(‘.box’).find(‘.bar’));</p><p>​    // 4. 获取所有的兄弟元素（不包括自己）</p><p>​    console.log($(‘.bar’).siblings(‘.foo’));</p><p>​    // 注意：以上方法的小括号中都可以使用 jq 的选择器字符串</p><h5 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h5><p>​    // 1. 获取上一个元素</p><p>​    console.log($(‘.foo’).prev());</p><p>​    // 2. 获取前面所有的元素</p><p>​    console.log($(‘.foo’).prevAll());</p><p>​    // 3. 获取下一个元素</p><p>​    console.log($(‘.foo’).next());</p><p>​    // 4. 获取后面所有的元素</p><p>​    console.log($(‘.foo’).nextAll());</p><p>​    // 3. 判断某个元素是否包含某个特定的类名</p><p>​    console.log($(‘.foo’).hasClass(‘foo’));</p><p>​    // 4. (重要) 获取第 n 个子元素 （元素索引 n 从 0 开始）</p><p>​    console.log($(‘li’).eq(2));</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>git命令</title>
    <link href="/2021/02/09/git%E5%91%BD%E4%BB%A4/"/>
    <url>/2021/02/09/git%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h2 id="git命令"><a href="#git命令" class="headerlink" title="git命令"></a>git命令</h2><p>添加全部未追踪文件    git add .</p><p>移除暂存区的对应文件  git reset HEAD file名 -</p><p>提交文件 git commit -m ‘修改内容’</p><p>查看文件状态 git status </p><p>配置git用户名和邮箱 git config –global user.name=”xxx”  git config –global user.email=”<a href="mailto:&#120;&#120;&#x78;&#x40;&#x71;&#113;&#46;&#99;&#111;&#109;">&#120;&#120;&#x78;&#x40;&#x71;&#113;&#46;&#99;&#111;&#109;</a>“</p><p>查看全局配置 git config –list –global</p><p>初始化git仓库 nvm init</p><p>把工作区中所有的修改还原到上一个最新版本中的状态 git checkout – [file]</p><p>跳过暂存区直接把文件提交到仓库 git commit -a -m ‘修改信息’</p><p>把暂存区和工作区的文件移除 git rm -r [file]</p><p>把暂存区的文件删除但保留工作区文件  git rm -r –cached[file]</p><p>查看历史记录 git log –oneline</p><p>切换版本 git reset –hard [commitID]</p><p>查看所有状态 git reflog –oneline</p><p>初始化git仓库命令 git init</p><p>关联github仓库 $ git remote add origin <a href="mailto:&#x67;&#105;&#116;&#x40;&#x67;&#105;&#116;&#104;&#x75;&#98;&#46;&#x63;&#111;&#x6d;">&#x67;&#105;&#116;&#x40;&#x67;&#105;&#116;&#104;&#x75;&#98;&#46;&#x63;&#111;&#x6d;</a>:qq919710247/my-project.git</p><p>将分支推入仓库 git push -u origin master （第一个之后直接git push即可） </p><p>克隆远程仓库 git clone [远程仓库的 git 地址]</p><p><u><em>提交步骤：1.git add  2.git commit -m ‘修改内容’  3.git push</em></u></p><h3 id="关联新的guthub"><a href="#关联新的guthub" class="headerlink" title="关联新的guthub"></a>关联新的guthub</h3><p>1.生成ssh密钥 ssh-keygen -t rsa -b 4096 -C 注册github时的邮箱(已生成)</p><p>2.复制公钥到github =&gt; Setting =&gt; SSH =&gt; And New SSH中</p><p>3.检查ssh是够配置成功 ssh -T <a href="mailto:&#103;&#105;&#x74;&#x40;&#103;&#x69;&#x74;&#x68;&#117;&#x62;&#x2e;&#x63;&#x6f;&#x6d;">&#103;&#105;&#x74;&#x40;&#103;&#x69;&#x74;&#x68;&#117;&#x62;&#x2e;&#x63;&#x6f;&#x6d;</a></p><p>4.克隆远程仓库 git clone [远程仓库的 git 地址]（在code里面）</p><h3 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h3><p>分支查询 git branch</p><p>新建分支 git branch dev-shop</p><p>切换分支 git checkout dev-shop</p><p>创建并跳转到某分支(基于master) git checkout -b dev-pay</p><p>再合并功能分支 git merge [功能分支]</p><p>查看远程分支信息 git remote show origin</p><p>删除本地分支  git branch -d dev-shop.html</p><p>删除远程分支 git push origin –delete 远程分支名</p><p>将本地分支推送到远程仓库 git push -u origin 本地分支名:远程分支名</p><p>查看远程仓库所有分支信息 git remote show origin</p><p>删除远程分支  git push origin –delete 远程分支名</p><h3 id="git忽略文件"><a href="#git忽略文件" class="headerlink" title="git忽略文件"></a>git忽略文件</h3><p>文件的规范-0</p><p>​      \1. 以 <code>#</code> 开头表示注释</p><p>​      \2. 以 <code>/</code> 结尾表示目录，忽略所有文件夹下的该文件</p><p>​      \3. 以 <code>/</code> 开头防止递归，忽略此文件夹下的该文件</p><p>​      \4. 以 <code>!</code> 开头表示取反</p><p>​      \5. 可以使用 glob 模式进行文件和文件夹的匹配</p><p>glob 模式包含的正则</p><p>​      (1) * 表示匹配零个或多个任意字符</p><p>​      (2) [abc] 表示匹配方括号中的任意一个字符</p><p>​      (3) ? 表示只匹配任意一个字符</p><p>​      (4) ** 表示匹配任意中间的目录, 比如 a/**/b 匹配 a/c/b 和 a/c/d/b</p><h3 id="git关联项目步骤"><a href="#git关联项目步骤" class="headerlink" title="git关联项目步骤"></a>git关联项目步骤</h3><p>1.配置用户名邮箱</p><p>2.ssh公钥链接</p><p>3.git clone</p><p>4.切换回到本地分支 </p><p>5.提交 add .   commit -m</p><p>6.pull(解决可能的冲突)</p><p>7.push</p><h3 id="git新建项目步骤"><a href="#git新建项目步骤" class="headerlink" title="git新建项目步骤"></a>git新建项目步骤</h3><p>1.git init</p><p>2.git add .</p><p>3.git commit -m ‘value’</p><p>4.git remote add origin [远程仓库地址]</p><p>5.git push -u oringin master</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Ajax</title>
    <link href="/2021/02/09/Ajax/"/>
    <url>/2021/02/09/Ajax/</url>
    
    <content type="html"><![CDATA[<h1 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h1><h3 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h3><p>​    一、URL地址 (链接)</p><p>​    互联网资源的统一定位标识符, 用来标识互联网上每个资源的存放位置</p><p>​    二、URL地址的三部分组成</p><p>​      <a href="http://www.baidu.com/home/index.html?uname=tom&amp;age=20">http://www.baidu.com/home/index.html?uname=tom&amp;age=20</a></p><p>​      协议、域名、地址</p><h4 id="客户端和服务器通信过程"><a href="#客户端和服务器通信过程" class="headerlink" title="客户端和服务器通信过程"></a>客户端和服务器通信过程</h4><p>​    \1. 客户端发送请求 </p><p>​    \2. 服务器处理这个请求  </p><p>​    \3. 服务器把数据发送给客户端, 完成响应</p><h4 id="jquery-中-ajax-的请求方法"><a href="#jquery-中-ajax-的请求方法" class="headerlink" title="jquery 中 ajax 的请求方法"></a>jquery 中 ajax 的请求方法</h4><p>​      \1. $.get()   用于发送 GET 请求，获取数据</p><p>​      \2. $.post()  用于发送 POST 请求，提交数据</p><p>​      \3. $.ajax({ })  用于发送任意 HTTP 请求，可以获取和提交数据</p><h4 id="get-和-post-请求的区别-面试"><a href="#get-和-post-请求的区别-面试" class="headerlink" title="get 和 post 请求的区别 (面试)"></a>get 和 post 请求的区别 (面试)</h4><p>​      \1. get 请求发送的参数放在 url 中, post 参数放在 请求体 中, 相对安全</p><p>​      \2. get 请求会被缓存到浏览器, post 不会被缓存</p><p>​      \3. get 请求的参数有长度限制, post 发送数据量比 get 大, 且支持发送二进制数据</p><h4 id="表单属性"><a href="#表单属性" class="headerlink" title="表单属性"></a>表单属性</h4><p>​      <em>1. action 属性</em></p><p>​      <em>决定了表单的数据提交到何处, 一般是一个 url 地址; 如果没有指定, 默认提交到当前页面</em></p><p>​      <em>2. target 属性</em></p><p>​      <em>规定了在何处打开 url, 默认值是 _self (当前标签页), _blank 表示在新标签页打开</em></p><p>​      <em>3. method 属性</em></p><p>​      <em>使用何种方式把表单数据提交到 url, 默认的方式是 GET 方式, 还可以指定 POST 提交</em></p><p>​      <em>4. get 和 post 提交数据的特点</em></p><p>​      <em>简单的数据提交使用 get, 复杂或隐蔽的数据使用 post</em></p><p>​      <em>5. enctype 属性 (编码方式)</em></p><p>​      <em>规定了在发送表单数据之前如何对数据进行编码</em></p><p>​      <em>默认是:  (1) application/x-www-form-urlencoded 表示在发送前编码所有的字符</em></p><p>​              <em>(2) multipart/form-data 不对字符进行编码, 在传输文件时必须使用这个值</em></p><p>​              <em>(3) text/plain 空格转成 + 号, 不对特殊字符进行编码 (少用)</em></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>js的知识点</title>
    <link href="/2021/01/29/js%E9%AB%98%E7%BA%A7/"/>
    <url>/2021/01/29/js%E9%AB%98%E7%BA%A7/</url>
    
    <content type="html"><![CDATA[<h1 id="js高级"><a href="#js高级" class="headerlink" title="js高级"></a>js高级</h1><h2 id="编程思想"><a href="#编程思想" class="headerlink" title="编程思想"></a>编程思想</h2><p>一、面向对象编程 (OOP)<br>  把功能事务分解成一个个对象，通过对象之间的分工合作来完成</p><p>  ex: 把大象放进冰箱<br>  面向对象：1. 大象（走进去） 2. 冰箱（开关门）</p><p>  ex: 小明今天买了一本书<br>  面向对象: 1. 小明 2. 书</p><p>二、面向对象 [高内聚, 低耦合]  vs 面向过程<br>  面向对象：易于维护、拓展，耦合性低；适用场景：多人合作的复杂项目<br>  面向过程：不易于维护、拓展，耦合性高；适用场景：简单的功能模块</p><p>三、面向对象的三个特性</p><pre><code>1. 封装性：把公共的特征提取出来，封装在一个模板中2. 继承性：类进行实例化，得到的具体的对象3. 多态性：生成多个对象</code></pre><h2 id="ES6-中使用-class-声明创建一个基于原型继承的具有指定名称的类"><a href="#ES6-中使用-class-声明创建一个基于原型继承的具有指定名称的类" class="headerlink" title="ES6 中使用 class 声明创建一个基于原型继承的具有指定名称的类"></a>ES6 中使用 class 声明创建一个基于原型继承的具有指定名称的类</h2><p>​    一、如何定义一个类</p><p>​      class 类名 {</p><p>​        // 构造函数: 定义公共的属性</p><p>​        constructor (参数) { </p><p>​          this.属性名 = 属性值</p><p>​        }</p><p>​        // 类方法: 定义公共的行为</p><p>​        方法名1 (参数) {  }</p><p>​        方法名2 (参数) {  }</p><p>​      }</p><p>​     </p><p>​     二、注意要点</p><p>​      1. class 创建的类首字母还是要大写</p><p>​      2. 类中的 constructor 构造函数, 接收 new 创建对象传递的参数，并返回实例对象（return this）</p><p>​      3. new 一个类时，自动调用构造函数方法，但不会自动调用类方法</p><p>​      4. 类中的构造函数 和 类方法不需要加 function （重点）</p><p>​      5. 多个类方法之间不需要使用逗号隔开 (重点)</p><p>​     三、大括号总结</p><p>​      1. 函数体 fn () {}</p><p>​      2. 定义对象 var obj = {}</p><p>​      3. 条件语法 if () {}</p><ol start="4"><li><p>定义一个类 class 类名 {}</p></li><li><p>使用类的两个注意事项</p><p>​      (1) 声明 class 类不存在变量提升，先定义再使用</p><p>​      (2)在类中访问属性和方法，必须加 this</p></li></ol><h2 id="extends和super"><a href="#extends和super" class="headerlink" title="extends和super"></a>extends和super</h2><p>​    1. 定义一个类（子类）通过 extends 继承父类上的方法和属性</p><p>​    class 子类名 extends 父类 {}</p><p>​    2. super 关键字可以访问和调用父类上的函数，包括构造函数和类方法</p><p>​    注意：</p><p>​    （1）子类调用方法时的查找顺序：先从子类上找再从父类上找</p><p>​    （2）super 作为一个函数，可以调用父类的构造函数；作为一个对象，可以调用父类的方法</p><h2 id="类中this指向问题"><a href="#类中this指向问题" class="headerlink" title="类中this指向问题"></a>类中this指向问题</h2><p>1.非函数作用域中始终指向window</p><p>2.函作用域中始终指向调用者</p><h2 id="实例成员和静态成员"><a href="#实例成员和静态成员" class="headerlink" title="实例成员和静态成员"></a>实例成员和静态成员</h2><ol><li>实例成员: 只能通过实例对象才能访问的属性或方法</li></ol><ol start="2"><li>静态成员: 只能通过构造函数本身才能访问的属性或方法</li></ol><h2 id="构造函数原型"><a href="#构造函数原型" class="headerlink" title="构造函数原型"></a>构造函数原型</h2><p>​    一、构造函数中直接添加方法的缺点</p><p>​      每次创建对象，要重复开辟内存空间，浪费资源 </p><p>​    二、构造函数的原型 prototype</p><ol><li>每个函数默认都有一个 prototype 属性, 它的值默认是一个对象</li></ol><p>​      2. 在 prototype 对象上的方法和属性, 会被 new 构造函数() 创建出来的实例对象所继承</p><p>​    三、注意:</p><p>​      (1) 只要是函数就默认有 prototype 属性, 但非函数的对象是不具有的</p><p>​      (2) 定义构造函数时, 公共的方法定义在原型对象上, 这样可以被所有创建出来的实例直接继承</p><h2 id="对象原型"><a href="#对象原型" class="headerlink" title="对象原型"></a>对象原型</h2><p>​    一、对象的原型</p><p>​    每个对象都默认有一个 <strong>proto</strong> 的属性, 它的值是一个对象, 默认指向创建这个对象的构造函数的原型</p><p>​    二、对象原型的访问特点</p><p>​     每个对象访问 <strong>proto</strong> 下的所有属性和方法，可以省略<strong>proto</strong></p><p>​    三、对象上读取属性的顺序</p><p>​      先从自身的属性上进行查找，如果没有再去 <strong>proto</strong> 属性指向的对象上去查找（就近原则）</p><h2 id="构造函数、对象原型、实例的关系"><a href="#构造函数、对象原型、实例的关系" class="headerlink" title="构造函数、对象原型、实例的关系"></a>构造函数、对象原型、实例的关系</h2><p>​    1. 每个构造函数都有一个 prototype 属性, 只要是这个构造函数生成的实例对象, 都会继承 prototype 的属性</p><p>​    2. 每个对象都有一个 <strong>proto</strong> 属性，指向创建对象时构造函数的原型对象 prototype; </p><p>​    3. 每个原型对象上默认都有一个 constructor 属性，它指向构造函数本身</p><h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><p>  原型链理解（面试常问）</p><p>  每个实例对象（ object ）都有一个私有属性（称之为 <strong>proto</strong> ）指向创建它的构造函数的原型对象（prototype ）。</p><p>  该原型对象也有一个自己的原型对象( <strong>proto</strong> ) ，层层向上直到一个对象的对象原型为 null。</p><p>  注意: 根据定义，null 没有原型，并作为这个原型链中的最后一个环节</p><p>​    第二点: 对象访问属性时遵从原型链的顺序</p><p>​    (1) 当访问一个对象的属性时，首先从这个对象自身进行查找</p><p>​    (2) 如果没有找到就从它的原型对象（__proto__）中查找</p><h2 id="构造函数和原型"><a href="#构造函数和原型" class="headerlink" title="构造函数和原型"></a>构造函数和原型</h2><h3 id="扩展原型对象的方法"><a href="#扩展原型对象的方法" class="headerlink" title="扩展原型对象的方法"></a>扩展原型对象的方法</h3><p>​    原型链的应用：拓展内置对象上自定义方法</p><ol><li><p>需求：修改数组 Array 上的原型对象，添加自定义求和的方法</p></li><li><p>拓展原型对象上的方法时，不能直接覆盖原来的原型对象，只能添加或和修改方法</p><p>注意：内置对象（如：Object, Array, Function） 上的原型对象不允许进行覆盖，只允许修改</p></li></ol><h2 id="类的本质"><a href="#类的本质" class="headerlink" title="类的本质"></a>类的本质</h2><p>​      es6 之前构造函数的特点:</p><p>​      1. 构造函数默认有一个 prototype 属性, 它的值是一个对象</p><p>​      2. 构造函数 prototype 属性下有 constructor 和 <strong>proto</strong> 两个默认的属性</p><p>​      3. 构造函数可以通过在 prototype 上添加方法, 去实现所有实例继承</p><p>​      4. 构造函数创建的实例上 __proto__指向创建它构造函数的 prototype</p><p>​      class 类的本质其实就是一个改造版的构造函数</p><h2 id="ES5数组新增方法"><a href="#ES5数组新增方法" class="headerlink" title="ES5数组新增方法"></a>ES5数组新增方法</h2><ol><li>forEach() 方法可以快速地遍历数组</li></ol><p>​    参数：callback(元素, 索引, 数组本身)</p><p>​    返回值：无</p><p>​    例子: 使用 forEach 对数组求和</p><ol start="2"><li>filter() 方法从数组筛选出符合条件的一组元素</li></ol><p>​    参数：callback(元素, 索引, 数组本身)</p><p>​    返回值：新数组</p><p>​    例子: 使用 filter 筛选数组中所有偶数</p><ol start="3"><li>some() 方法用于查找数组中是否有符合条件的某一个元素</li></ol><p>​    参数：callback(元素, 索引, 数组本身)</p><p>​    返回值：true(找到) || false(找不到)</p><p>   4.every() 方法用于查找数组中是否所有的元素都符合条件</p><p>​    参数：callback(元素, 索引, 数组本身)</p><p>​    返回值：true || false (只有有一个不满足就返回 false)</p><h2 id="Object-defineProperty方法"><a href="#Object-defineProperty方法" class="headerlink" title="Object.defineProperty方法"></a>Object.defineProperty方法</h2><p>​      (1) value: 属性值 </p><p>​      (2) writable: 是否可以修改</p><p>​      (3) enumerable: 是否可以枚举（遍历到）</p><p>​      (4) configurable: 是否可以删除或再次修改特性</p><p>​      三个属性描述符默认都是 false </p><h2 id="手动改变this指向"><a href="#手动改变this指向" class="headerlink" title="手动改变this指向"></a>手动改变this指向</h2><p>​    一、call 方法</p><p>​      fn.call([thisArg, arg1, arg2…])</p><p>​      作用：调用一个函数，并指定调用时 this 的值</p><p>​      参数: thisArg 函数中 this 的指定值； arg1, arg2…可选的参数列表</p><p>​      返回值：函数调用的结果</p><p>​    注意</p><p>​      第一个参数 thisArg 如果不传或是 null、undefined，默认函数内 this 指向 window </p><p>​    二、apply 方法</p><p>​      fn.apply(thisArg[, argsArray])</p><p>​      作用：调用一个函数，并指定调用时 this 的值</p><p>​      参数: thisArg 函数中 this 的指定值； argsArray 可选的参数数组(!!)</p><p>​      返回值：函数调用的结果</p><p>​    apply 应用</p><p>​      由于可以接受一个参数数组，所以对于数组元素的遍历操作可以使用 apply;</p><p>​      在可以使用 call 的情况下， 都可以使用 apply 替代 </p><p>​    三、bind 方法</p><p>​      var newFn = fn.bind(thisArg[, arg1, arg2, …])</p><p>​      作用：基于原函数创建一个新函数，这个新函数的 this 被指定为第一个参数， 其余参数作为实参传递给新函数</p><p>​      参数：thisArg 是新函数内 this 的预设值; arg1, arg2 是新函数预设传入的参数</p><p>​      返回值: 新函数</p><p>​    bind 作用</p><p>​      (1) 创建一个函数，不论怎么调用，这个函数都有同样的 this 值</p><p>​      (2) 使一个函数拥有预设的初始参数 </p><h2 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h2><p>​    一、什么是严格模式 （了解）</p><p>​      采用具有限制性JavaScript变体的一种方式，摆脱了以前的松散模式</p><p>​      1. 消除了 js 代码的不合理和不严谨地方，减少怪异行为</p><p>​      2. 消除了代码的不安全地方，保证代码安全运行</p><p>​      3. 提高编译器的效率，增加运行的速度</p><p>​      4. 禁用 ECMAScript 未来版本中可能会定义的一些语法 class extends super 等</p><p>   严格模式的应用</p><p>​      1. 为整个 js 文件开启严格模式, 即在代码开头添加 ‘use strict’;</p><ol start="2"><li>为某个函数开启严格模式, 即函数体代码开头添加 ‘use strict’; </li></ol><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>​    一、闭包的概念 </p><p>​      内部函数访问外部函数声明的变量，这种组合方式就是闭包</p><p>​    二、JS 中的垃圾回收机制(GC)</p><p>​      垃圾回收机制会定期（周期性）找出那些不再引用到的内存（变量），然后释放其内存</p><p>​    三、闭包产生的原因</p><p>​     (1) 当一个函数内的声明的变量没有被其他函数引用时，那么调用完这个函数后，</p><p>​      所有的局部变量就会被垃圾回收机制清除；</p><p>​     (2) 一旦这个变量被另外一个函数所引用，这个变量的值会始终保存在内存中，</p><p>​      不会被垃圾回收机制回收，从而形成了闭包 </p><p>​    一、闭包的作用</p><p>​      （1）延伸了变量的使用范围</p><p>​      （2）实现了数据的封装</p><p>​      （3）实现了数据的缓存（函数的柯里化）</p><p>​    二、闭包的缺点 (了解)</p><p>​      (1) 闭包会使得函数中的变量都被保存在内存中，加大了内存消耗 (空间换时间)</p><p>​      (2) 容易引发内存泄漏 (内存没有及时清理)</p><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>​    一、递归函数</p><p>​      函数内部自己调用自己，作用和循环效果类似 </p><p>​    二、递归的注意事项</p><p>​      递归很容易发生 “栈溢出” 错误，所以和 while 循环类似必须要添加中断条件 </p><h2 id="拷贝"><a href="#拷贝" class="headerlink" title="拷贝"></a>拷贝</h2><p>​    一、浅拷贝</p><p>​      只拷贝对象一层的数据，复杂数据类型只拷贝内存地址值（引用同一个对象） </p><p>  一、深拷贝</p><p>​      拷贝对象多层的数据，遇到复杂数据类型会继续新建一个空间，拷贝里面每一层的属性和值</p><p>  二、和浅拷贝的区别</p><p>​    深拷贝后的对象和原对象是完全隔离的，各自互不影响， 而浅拷贝中所有复杂数据类型的值，都是共同引用的</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>关于如何建立博客步骤</title>
    <link href="/2021/01/28/hello-world/"/>
    <url>/2021/01/28/hello-world/</url>
    
    <content type="html"><![CDATA[<ol><li>安装全局的 hexo-cli 包</li><li>初始化 Blog 项目</li><li>创建 github 仓库</li><li>配置本地项目和 github 仓库相关联</li><li>选择一款皮肤</li><li>重新启动</li><li>修改主题配置</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
